// Что в итоге хочется получить
// валидные разделители -,~_()`
// M                   ::= public static void $name$() {}
// Mi                  ::= public static int $name$() {}
// _M~i                ::= private static IEnumerable<int> $name$() {}
// MMain,itest         ::= public static void Main(int test) {}
// MMain,oitest        ::= public static void Main(out int test) {}
// MMain`i,i,itest     ::= public static void Main<int,int>(int test) {}
// m~dHello,detest,sbi ::= public IEnumerable<double> Hello(decimal test, StringBuiler i){}

space ::= " "

// Resharper macros
cursor ::= "$END$"
manualType ::= "$type$"

// Fields
field ::= <accessField> ""=f <space> <type> "$name$" ";"

identifier ::= [Ll Lu Lt Lo Nd Nl Mn Mc Cf Pc Lm]

// Methods
method       ::= <accessMethod> <methodDecl> <space> <manualType> <space> <methodName> "(" <cursor> "){}"
methodname   ::=  "$name$" | <identifier>
methodDecl   ::= <space> static=M | ""=m
accessMethod ::= "public" | private=_ | protected=pr

// Auto properties
property        ::= <accessProperty> <space> <manualType> <space> "$name{get; " <lazyPrivateSpec> "set;}"
accessProperty  ::= "public"=p | private=_ | protected=P
lazyPrivateSpec ::= "private "=_ | ""

// Plain types
arraySpec  ::= "[]"=s | ""
type       ::= <primType> | <compType>
primType   ::= string=s | byte=b | double=d | <manualType>

// Complex types
genericArg  ::= "<" <primType> ">"
scgTypes    ::= IList=l | IEnumerable=e
generic2Arg ::= "<" <primType> ">"
scg2Types   ::= SortedList=sl | IDictionary=di
SCG         ::= "System.Collections.Generic"
compType    ::= <SCG> "." <scgTypes> <genericArg> | <SCG> "." <scg2Types> <generic2Arg>

scope "InCSharpTypeMember" {
  //start    ::= <field> | <method> | <property>
  start    ::=  <method>
}

scope "InCSharpTypeAndNamespace" {

}
