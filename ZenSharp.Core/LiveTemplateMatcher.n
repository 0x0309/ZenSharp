using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using NLog;

namespace Github.Ulex.ZenSharp.Core
{
  public class LiveTemplateMatcher
  {
    private static _log = LogManager.GetCurrentClassLogger();
    
    private _tree : GenerateTree;

    public this(tree : GenerateTree) {
      _tree = tree;
    }

    [Record]
    public class MatchResult {
      public Success : bool { get; private set; }
      public Tail : string { get; private set };
      public Rules : list[LeafRule] { get; private set; }

      public this(mr : bool) {
        Success = mr;
      }

      public Expand(prefix : string) : string {
        def builder = System.Text.StringBuilder();
        foreach (r in ReMatchLeafs(prefix)){
          _ = builder.Append(r.Expand)
        }
        builder.ToString();
      }

      public ReMatchLeafs(prefix : string) : IEnumerable[LeafRule.LeafMatchResult]{
        def loop(tail, input, acc){
          match (tail){
            | x :: xs => {def matchResult = x.Match(input); loop(xs, matchResult.Crop(input), matchResult :: acc); }
            | _ => acc
          }
        }
        loop(Rules, prefix, []).Reverse();
      }
    }

    public Match (prefix : string, scopename : string) : MatchResult
    {
      _log.Info("Trying to match [{0}] in scope {1}", prefix, scopename);
      def scope = _tree.GetScope(scopename);
      
      // scope rules can override global rules
      def scopeRules = scope.Rules + _tree.GlobalRules;

      // circle reference fix
      mutable tryMatchRuleVar;

      def tryMatchLeafRule(rule : LeafRule, acc : MatchResult) : MatchResult {
        match (rule){
          | x is LeafRule.NonTerminal => tryMatchRuleVar(_tree.GetRule(x.Value, scopeRules).Rules, acc);
          | x is LeafRule.InsideRule => tryMatchRuleVar(x.Rules, acc);
          | lr => {
              def leafMatch = lr.Match(acc.Tail);
              MatchResult(leafMatch.Success, leafMatch.Crop(acc.Tail), rule :: acc.Rules)
            }
        }
      }

      def tryMatchConcatRule (rules : list[LeafRule], acc : MatchResult) : MatchResult {
        match (rules) {
          | x :: xs => {
            def r = tryMatchLeafRule(x, acc);
            if (!r.Success)
              r
            else
              tryMatchConcatRule(xs, r);
          }
          | _ => acc;
        }
      }

      def tryMatchRule (rules : list[ConcatRule], acc : MatchResult) : MatchResult {
        match (rules) {
          | x :: xs =>
            {
              def r = tryMatchConcatRule(x.Rules, acc);
              if (r.Success)
                r
              else
                tryMatchRule(xs, acc);
            };
          | _ => MatchResult(false, acc.Tail, acc.Rules);
        }
      }
      tryMatchRuleVar = tryMatchRule;

      def result = tryMatchRule(_tree.GetStartRule(scope).Rules, MatchResult(true, prefix, []));
      _log.Info("Match result: {0}, tail: {1}, rules: {2}", result.Success, result.Tail, result.Rules);
      
      MatchResult(result.Success, result.Tail, result.Rules.Reverse());
    }
  }
}
